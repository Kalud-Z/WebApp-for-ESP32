https://github.com/Kalud-Z/Thesis-data-generator-webapp

###############################################################################

https://blog.appsignal.com/2022/01/19/how-to-set-up-a-nodejs-project-with-typescript.html

compile the code into js:
npx tsc  


run the js file :
node main.js

run ts file directly :
npx ts-node src/main.ts 


ws://localhost:8999


########################################################################################################



okay lets start with the data generator.
Im gonne be building it in Nodejs, and use Websockets.


#############################################################################################################################


120 kbps



87780270000ns 751 555
87800417000ns 750 557
87820270000ns 747 555
87840456000ns 752 560
87860609000ns 749 553
87880405000ns 749 554
87900552000ns 753 555
87920694000ns 751 559
87940495000ns 752 556
87960642000ns 751 555
87980783000ns 746 553
88000933000ns 750 557
88020784000ns 751 555
88040973000ns 749 558
88060783000ns 751 559
88080932000ns 750 553
88101078000ns 749 560
88120882000ns 752 558
88141023000ns 749 556
88161171000ns 751 558
88181312000ns 750 553
88201118000ns 747 558
88221312000ns 749 556
88241152000ns 751 558
88261309000ns 749 555
88281455000ns 748 557
88301589000ns 754 554
88321394000ns 748 557
88341539000ns 748 556
88361690000ns 748 559
88381493000ns 751 555
88401645000ns 748 554
88421842000ns 751 557
88441682000ns 747 560




#################################################################################


TODO : monitor buffer and latency :



Sending data at 1ms intervals is extremely fast, and this can overload the WebSocket buffer if the sending rate exceeds the underlying system's capacity to send data out over the network. To monitor the process and see what's happening with your data in real time, you would typically do the following:

1. **Buffer Monitoring**: Track the amount of data in the WebSocket buffer to see if it's building up over time.
2. **Latency Monitoring**: Measure the time it takes from when you put the data into the buffer to when the `on('drain')` event is emitted, which indicates that the data has been flushed from the buffer.

Here's how you can incorporate this into your server code:

```javascript
// ... other imports and initialization code ...

wss.on('connection', (ws: WebSocket) => {
    console.log('WebSocket connection established');
    ws.send(JSON.stringify({ type: 'configuration', channels: 2 }));

    let totalBytesSent = 0;
    let lastLoggedTime = Date.now();
    let secondsElapsed = 0;
    let messagesInTransit = 0; // Track how many messages have been sent but not yet acknowledged

    // ... generateDummySensorData function ...

    const intervalId = setInterval(() => {
        const dataBuffer = generateDummySensorData();
        totalBytesSent += dataBuffer.length;
        messagesInTransit++;

        const bufferIsFull = !ws.send(dataBuffer, () => {
            messagesInTransit--; // Acknowledgment callback, called when the data is actually sent
        });

        if (bufferIsFull) {
            console.log('Buffer is full, waiting for drain');
            ws.once('drain', () => {
                console.log('Buffer drained, resuming');
            });
        }

        // ... logging logic ...
    }, 1); // 1ms interval

    // ... rest of the WebSocket event handlers ...
});

// ... rest of the server setup code ...
```

**Monitoring buffer size**: In this code snippet, the `bufferIsFull` variable will become `true` if the WebSocket's internal buffer is full. The WebSocket's `send` function will return `false` in this case, as per the Node.js stream backpressure concept.

**Monitoring latency**: The acknowledgment callback in the `ws.send` method is called when the data has actually been transmitted. If you track when you send a message and when the callback is called, you can measure the latency.

Additionally, you may want to implement some backpressure mechanism, like pausing the data generation when the buffer is full and resuming it once the 'drain' event is emitted.

Keep in mind that trying to send data at 1ms intervals will likely cause issues with most networks and can be very resource-intensive for the server. It is often necessary to batch messages or send them at a less frequent interval to ensure the system's stability.







___________________________________________________________________________________________________________________________________________________
